diff --git a/src/mesh/NextHopRouter.cpp b/src/mesh/NextHopRouter.cpp
index f21974a2e..b920b84bf 100644
--- a/src/mesh/NextHopRouter.cpp
+++ b/src/mesh/NextHopRouter.cpp
@@ -79,6 +79,15 @@ void NextHopRouter::sniffReceived(const meshtastic_MeshPacket *p, const meshtast
                         LOG_INFO("Update next hop of 0x%x to 0x%x based on ACK/reply", p->from, p->relay_node);
                         origTx->next_hop = p->relay_node;
                     }
+                    // Also update the next hop candidate with the successful relay
+                    uint8_t hopCount = p->hop_start - p->hop_limit;
+                    LOG_DEBUG("Updating next hop candidate for node 0x%x: candidate=0x%x, hop_count=%d", p->from, p->relay_node, hopCount);
+                    if (nodeDB->updateNextHopCandidates(p->from, p->relay_node, hopCount)) {
+                        uint8_t bestHop = nodeDB->getBestNextHop(p->from);
+                        LOG_DEBUG("Best next hop for node 0x%x is now 0x%x", p->from, bestHop);
+                    } else {
+                        LOG_DEBUG("Failed to update next hop candidate for node 0x%x", p->from);
+                    }
                 }
             }
         }
@@ -129,6 +138,10 @@ uint8_t NextHopRouter::getNextHop(NodeNum to, uint8_t relay_node)
 
     meshtastic_NodeInfoLite *node = nodeDB->getMeshNode(to);
     if (node && node->next_hop) {
+        // Debug: Compare original next hop with best candidate
+        uint8_t bestHop = nodeDB->getBestNextHop(to);
+        LOG_DEBUG("Next hop comparison for node 0x%x: original=0x%x, best_candidate=0x%x", to, node->next_hop, bestHop);
+        
         // We are careful not to return the relay node as the next hop
         if (node->next_hop != relay_node) {
             // LOG_DEBUG("Next hop for 0x%x is 0x%x", to, node->next_hop);
diff --git a/src/mesh/NodeDB.cpp b/src/mesh/NodeDB.cpp
index 28af7d308..1a400aeaf 100644
--- a/src/mesh/NodeDB.cpp
+++ b/src/mesh/NodeDB.cpp
@@ -1822,4 +1822,103 @@ void recordCriticalError(meshtastic_CriticalErrorCode code, uint32_t address, co
     LOG_ERROR("A critical failure occurred, portduino is exiting");
     exit(2);
 #endif
+}
+
+bool NodeDB::updateNextHopCandidates(NodeNum nodeId, uint8_t candidateId, uint8_t hopCount)
+{
+    meshtastic_NodeInfoLite *info = getMeshNode(nodeId);
+    if (!info) {
+        return false;
+    }
+
+    // Find if this candidate already exists
+    int existingIndex = -1;
+    for (int i = 0; i < MAX_NEXT_HOP_CANDIDATES; i++) {
+        if (info->next_hop_candidates[i].node_id == candidateId) {
+            existingIndex = i;
+            break;
+        }
+    }
+
+    uint32_t now = getTime();
+    
+    if (existingIndex >= 0) {
+        // Update existing candidate
+        info->next_hop_candidates[existingIndex].hop_count = hopCount;
+        info->next_hop_candidates[existingIndex].packet_count++;
+        info->next_hop_candidates[existingIndex].last_heard = now;
+    } else {
+        // Find slot for new candidate
+        int emptySlot = -1;
+        for (int i = 0; i < MAX_NEXT_HOP_CANDIDATES; i++) {
+            if (info->next_hop_candidates[i].node_id == 0) {
+                emptySlot = i;
+                break;
+            }
+        }
+
+        if (emptySlot >= 0) {
+            // Add new candidate
+            info->next_hop_candidates[emptySlot].node_id = candidateId;
+            info->next_hop_candidates[emptySlot].hop_count = hopCount;
+            info->next_hop_candidates[emptySlot].packet_count = 1;
+            info->next_hop_candidates[emptySlot].last_heard = now;
+        } else {
+            // Replace worst candidate
+            int worstIndex = 0;
+            float worstScore = 0;
+            
+            for (int i = 0; i < MAX_NEXT_HOP_CANDIDATES; i++) {
+                // Score based on hop count, packet count, and recency
+                float score = (float)info->next_hop_candidates[i].packet_count / 
+                            (info->next_hop_candidates[i].hop_count * 
+                             (now - info->next_hop_candidates[i].last_heard + 1));
+                
+                if (score < worstScore || i == 0) {
+                    worstScore = score;
+                    worstIndex = i;
+                }
+            }
+            
+            info->next_hop_candidates[worstIndex].node_id = candidateId;
+            info->next_hop_candidates[worstIndex].hop_count = hopCount;
+            info->next_hop_candidates[worstIndex].packet_count = 1;
+            info->next_hop_candidates[worstIndex].last_heard = now;
+        }
+    }
+
+    // Update the next_hop field with the best candidate
+    info->next_hop = getBestNextHop(nodeId);
+    
+    return true;
+}
+
+uint8_t NodeDB::getBestNextHop(NodeNum nodeId)
+{
+    meshtastic_NodeInfoLite *info = getMeshNode(nodeId);
+    if (!info) {
+        return NO_NEXT_HOP_PREFERENCE;
+    }
+
+    uint32_t now = getTime();
+    uint8_t bestHop = NO_NEXT_HOP_PREFERENCE;
+    float bestScore = 0;
+
+    for (int i = 0; i < MAX_NEXT_HOP_CANDIDATES; i++) {
+        if (info->next_hop_candidates[i].node_id == 0) {
+            continue;
+        }
+
+        // Score based on hop count, packet count, and recency
+        float score = (float)info->next_hop_candidates[i].packet_count / 
+                     (info->next_hop_candidates[i].hop_count * 
+                      (now - info->next_hop_candidates[i].last_heard + 1));
+
+        if (score > bestScore) {
+            bestScore = score;
+            bestHop = info->next_hop_candidates[i].node_id;
+        }
+    }
+
+    return bestHop;
 }
\ No newline at end of file
diff --git a/src/mesh/NodeDB.h b/src/mesh/NodeDB.h
index 16159d380..e3c9f9e76 100644
--- a/src/mesh/NodeDB.h
+++ b/src/mesh/NodeDB.h
@@ -71,6 +71,17 @@ enum LoadFileResult {
 
 enum UserLicenseStatus { NotKnown, NotLicensed, Licensed };
 
+// Structure to track next hop candidates
+struct NextHopCandidate {
+    uint8_t node_id;           // The node ID of this candidate
+    uint8_t hop_count;         // Number of hops to reach destination through this node
+    uint32_t packet_count;     // Number of successful packets received through this node
+    uint32_t last_heard;       // Last time we heard from this node
+};
+
+// Maximum number of next hop candidates to track per node
+#define MAX_NEXT_HOP_CANDIDATES 3
+
 class NodeDB
 {
     // NodeNum provisionalNodeNum; // if we are trying to find a node num this is our current attempt
@@ -209,6 +220,22 @@ class NodeDB
     bool restorePreferences(meshtastic_AdminMessage_BackupLocation location,
                             int restoreWhat = SEGMENT_CONFIG | SEGMENT_MODULECONFIG | SEGMENT_DEVICESTATE | SEGMENT_CHANNELS);
 
+    /**
+     * Update the next hop candidates for a node
+     * @param nodeId The destination node
+     * @param candidateId The potential next hop node
+     * @param hopCount The number of hops through this candidate
+     * @return true if the candidates were updated
+     */
+    bool updateNextHopCandidates(NodeNum nodeId, uint8_t candidateId, uint8_t hopCount);
+
+    /**
+     * Get the best next hop candidate for a node
+     * @param nodeId The destination node
+     * @return The best next hop candidate ID, or NO_NEXT_HOP_PREFERENCE if none available
+     */
+    uint8_t getBestNextHop(NodeNum nodeId);
+
   private:
     uint32_t lastNodeDbSave = 0;    // when we last saved our db to flash
     uint32_t lastBackupAttempt = 0; // when we last tried a backup automatically or manually
