diff --git a/src/mesh/NextHopRouter.cpp b/src/mesh/NextHopRouter.cpp
index f21974a2e..6edfa21ae 100644
--- a/src/mesh/NextHopRouter.cpp
+++ b/src/mesh/NextHopRouter.cpp
@@ -20,6 +20,23 @@ ErrorCode NextHopRouter::send(meshtastic_MeshPacket *p)
     p->next_hop = getNextHop(p->to, p->relay_node); // set the next hop
     LOG_DEBUG("Setting next hop for packet with dest %x to %x", p->to, p->next_hop);
 
+    // Debug: Compare with NextHopSelector
+    uint8_t selectorHop = nextHopSelector.getBestNextHop(p->to, p->relay_node);
+    if (selectorHop != p->next_hop) {
+        LOG_INFO("[NextHopDebug] NextHopRouter chose %x, NextHopSelector suggests %x for dest %x", p->next_hop, selectorHop, p->to);
+        // Print top 3 candidates if available
+        // (Accessing internal structure for debug)
+        auto it = nextHopSelector.nextHopMap.find(p->to);
+        if (it != nextHopSelector.nextHopMap.end()) {
+            LOG_INFO("[NextHopDebug] Top candidates for dest %x:", p->to);
+            int rank = 1;
+            for (const auto& cand : it->second) {
+                LOG_INFO("  #%d: nodeId=%x, successRate=%.2f, success=%u, fail=%u", rank, cand.nodeId, cand.successRate, cand.successCount, cand.failureCount);
+                if (++rank > 3) break;
+            }
+        }
+    }
+
     // If it's from us, ReliableRouter already handles retransmissions if want_ack is set. If a next hop is set and hop limit is
     // not 0 or want_ack is set, start retransmissions
     if ((!isFromUs(p) || !p->want_ack) && p->next_hop != NO_NEXT_HOP_PREFERENCE && (p->hop_limit > 0 || p->want_ack))
diff --git a/src/mesh/NextHopRouter.h b/src/mesh/NextHopRouter.h
index 6c2764aff..d7ed0d464 100644
--- a/src/mesh/NextHopRouter.h
+++ b/src/mesh/NextHopRouter.h
@@ -2,6 +2,7 @@
 
 #include "FloodingRouter.h"
 #include <unordered_map>
+#include "NextHopSelector.h"
 
 /**
  * An identifier for a globally unique message - a pair of the sending nodenum and the packet id assigned
@@ -53,10 +54,10 @@ class GlobalPacketIdHashFunction
   relayer of a packet, which bases this on information from a previous successful delivery to the destination via flooding.
   Namely, in the PacketHistory, we keep track of (up to 3) relayers of a packet. When the ACK is delivered back to us via a node
   that also relayed the original packet, we use that node as next hop for the destination from then on. This makes sure that only
-  when there’s a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
+  when there's a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
   NextHopRouter only 1 time). For the final retry, if no one actually relayed the packet, it will reset the next hop in order to
   fall back to the FloodingRouter again. Note that thus also intermediate hops will do a single retransmission if the intended
-  next-hop didn’t relay, in order to fix changes in the middle of the route.
+  next-hop didn't relay, in order to fix changes in the middle of the route.
 */
 class NextHopRouter : public FloodingRouter
 {
@@ -97,6 +98,9 @@ class NextHopRouter : public FloodingRouter
      */
     std::unordered_map<GlobalPacketId, PendingPacket, GlobalPacketIdHashFunction> pending;
 
+    // Add NextHopSelector for debug/analysis
+    NextHopSelector nextHopSelector;
+
     /**
      * Should this incoming filter be dropped?
      *
