diff --git a/src/mesh/NextHopRouter.cpp b/src/mesh/NextHopRouter.cpp
index f21974a2e..008bc373b 100644
--- a/src/mesh/NextHopRouter.cpp
+++ b/src/mesh/NextHopRouter.cpp
@@ -17,7 +17,7 @@ ErrorCode NextHopRouter::send(meshtastic_MeshPacket *p)
     p->relay_node = nodeDB->getLastByteOfNodeNum(getNodeNum()); // First set the relayer to us
     wasSeenRecently(p);                                         // FIXME, move this to a sniffSent method
 
-    p->next_hop = getNextHop(p->to, p->relay_node); // set the next hop
+    p->next_hop = getNextHop(p->to, p->relay_node, p->id); // set the next hop
     LOG_DEBUG("Setting next hop for packet with dest %x to %x", p->to, p->next_hop);
 
     // If it's from us, ReliableRouter already handles retransmissions if want_ack is set. If a next hop is set and hop limit is
@@ -121,7 +121,7 @@ bool NextHopRouter::perhapsRelay(const meshtastic_MeshPacket *p)
  * Get the next hop for a destination, given the relay node
  * @return the node number of the next hop, 0 if no preference (fallback to FloodingRouter)
  */
-uint8_t NextHopRouter::getNextHop(NodeNum to, uint8_t relay_node)
+uint8_t NextHopRouter::getNextHop(NodeNum to, uint8_t relay_node, PacketId id)
 {
     // When we're a repeater router->sniffReceived will call NextHopRouter directly without checking for broadcast
     if (isBroadcast(to))
@@ -131,7 +131,25 @@ uint8_t NextHopRouter::getNextHop(NodeNum to, uint8_t relay_node)
     if (node && node->next_hop) {
         // We are careful not to return the relay node as the next hop
         if (node->next_hop != relay_node) {
-            // LOG_DEBUG("Next hop for 0x%x is 0x%x", to, node->next_hop);
+            // Get the next hop node info
+            meshtastic_NodeInfoLite *nextHopNode = nodeDB->getMeshNode(node->next_hop);
+            const char *nextHopName = nextHopNode && nextHopNode->has_user ? nextHopNode->user.long_name : "Unknown";
+            
+            // Get retries info
+            auto key = GlobalPacketId(to, id);
+            PendingPacket *pending = findPendingPacket(key);
+            int retries = pending ? pending->numRetransmissions : 0;
+            
+            // Log node name and RSSI if available
+            if (node->has_user) {
+                LOG_INFO("Next hop for node %s (0x%x) is %s (0x%x), SNR: %.2f dB, Retries: %d", 
+                    node->user.long_name, node->num, nextHopName, nextHopNode ? nextHopNode->num : node->next_hop, 
+                    node->snr, retries);
+            } else {
+                LOG_INFO("Next hop for node 0x%x is %s (0x%x), SNR: %.2f dB, Retries: %d", 
+                    node->num, nextHopName, nextHopNode ? nextHopNode->num : node->next_hop, 
+                    node->snr, retries);
+            }
             return node->next_hop;
         } else
             LOG_WARN("Next hop for 0x%x is 0x%x, same as relayer; set no pref", to, node->next_hop);
