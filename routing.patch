diff --git a/src/mesh/NextHopRouter.cpp b/src/mesh/NextHopRouter.cpp
index f21974a2e..65a773d93 100644
--- a/src/mesh/NextHopRouter.cpp
+++ b/src/mesh/NextHopRouter.cpp
@@ -18,7 +18,29 @@ ErrorCode NextHopRouter::send(meshtastic_MeshPacket *p)
     wasSeenRecently(p);                                         // FIXME, move this to a sniffSent method
 
     p->next_hop = getNextHop(p->to, p->relay_node); // set the next hop
-    LOG_DEBUG("Setting next hop for packet with dest %x to %x", p->to, p->next_hop);
+    LOG_INFO("[NextHopDebug] Setting next hop for packet with dest %x to %x (from nodeDB)", p->to, p->next_hop);
+
+    // Add the next hop as a candidate in NextHopSelector
+    if (p->next_hop != NO_NEXT_HOP_PREFERENCE) {
+        LOG_INFO("[NextHopDebug] Adding next hop %x as candidate for dest %x", p->next_hop, p->to);
+        nextHopSelector.addOrUpdateNextHop(p->to, p->next_hop);
+    }
+
+    // Debug: Compare with NextHopSelector
+    uint8_t selectorHop = nextHopSelector.getBestNextHop(p->to, p->relay_node);
+    LOG_INFO("[NextHopDebug] NextHopRouter chose %x, NextHopSelector suggests %x for dest %x", p->next_hop, selectorHop, p->to);
+    // Print top candidates if available
+    auto candidates = nextHopSelector.getTopCandidates(p->to);
+    if (!candidates.empty()) {
+        LOG_INFO("[NextHopDebug] Top candidates for dest %x:", p->to);
+        int rank = 1;
+        for (const auto& cand : candidates) {
+            LOG_INFO("  #%d: nodeId=%x, successRate=%.2f, success=%u, fail=%u", rank, cand.nodeId, cand.successRate, cand.successCount, cand.failureCount);
+            if (++rank > 3) break;
+        }
+    } else {
+        LOG_INFO("[NextHopDebug] No candidates available for dest %x", p->to);
+    }
 
     // If it's from us, ReliableRouter already handles retransmissions if want_ack is set. If a next hop is set and hop limit is
     // not 0 or want_ack is set, start retransmissions
@@ -78,6 +100,10 @@ void NextHopRouter::sniffReceived(const meshtastic_MeshPacket *p, const meshtast
                     if (origTx->next_hop != p->relay_node) { // Not already set
                         LOG_INFO("Update next hop of 0x%x to 0x%x based on ACK/reply", p->from, p->relay_node);
                         origTx->next_hop = p->relay_node;
+                        
+                        // Record success in NextHopSelector
+                        LOG_INFO("[NextHopDebug] Recording success for dest %x via nodeId %x", p->from, p->relay_node);
+                        nextHopSelector.recordSuccess(p->from, p->relay_node);
                     }
                 }
             }
@@ -124,17 +150,22 @@ bool NextHopRouter::perhapsRelay(const meshtastic_MeshPacket *p)
 uint8_t NextHopRouter::getNextHop(NodeNum to, uint8_t relay_node)
 {
     // When we're a repeater router->sniffReceived will call NextHopRouter directly without checking for broadcast
-    if (isBroadcast(to))
+    if (isBroadcast(to)) {
+        LOG_INFO("[NextHopDebug] getNextHop: Broadcast message, returning NO_NEXT_HOP_PREFERENCE");
         return NO_NEXT_HOP_PREFERENCE;
+    }
 
     meshtastic_NodeInfoLite *node = nodeDB->getMeshNode(to);
     if (node && node->next_hop) {
         // We are careful not to return the relay node as the next hop
         if (node->next_hop != relay_node) {
-            // LOG_DEBUG("Next hop for 0x%x is 0x%x", to, node->next_hop);
+            LOG_INFO("[NextHopDebug] getNextHop: Found next hop %x for dest %x in nodeDB", node->next_hop, to);
             return node->next_hop;
-        } else
-            LOG_WARN("Next hop for 0x%x is 0x%x, same as relayer; set no pref", to, node->next_hop);
+        } else {
+            LOG_WARN("[NextHopDebug] getNextHop: Next hop %x same as relayer %x for dest %x", node->next_hop, relay_node, to);
+        }
+    } else {
+        LOG_INFO("[NextHopDebug] getNextHop: No next hop found in nodeDB for dest %x", to);
     }
     return NO_NEXT_HOP_PREFERENCE;
 }
@@ -216,6 +247,9 @@ int32_t NextHopRouter::doRetransmissions()
                     LOG_DEBUG("Reliable send failed, returning a nak for fr=0x%x,to=0x%x,id=0x%x", p.packet->from, p.packet->to,
                               p.packet->id);
                     sendAckNak(meshtastic_Routing_Error_MAX_RETRANSMIT, getFrom(p.packet), p.packet->id, p.packet->channel);
+                    
+                    // Record failure in NextHopSelector
+                    nextHopSelector.recordFailure(p.packet->to, p.packet->next_hop);
                 }
                 // Note: we don't stop retransmission here, instead the Nak packet gets processed in sniffReceived
                 stopRetransmission(it->first);
diff --git a/src/mesh/NextHopRouter.h b/src/mesh/NextHopRouter.h
index 6c2764aff..d7ed0d464 100644
--- a/src/mesh/NextHopRouter.h
+++ b/src/mesh/NextHopRouter.h
@@ -2,6 +2,7 @@
 
 #include "FloodingRouter.h"
 #include <unordered_map>
+#include "NextHopSelector.h"
 
 /**
  * An identifier for a globally unique message - a pair of the sending nodenum and the packet id assigned
@@ -53,10 +54,10 @@ class GlobalPacketIdHashFunction
   relayer of a packet, which bases this on information from a previous successful delivery to the destination via flooding.
   Namely, in the PacketHistory, we keep track of (up to 3) relayers of a packet. When the ACK is delivered back to us via a node
   that also relayed the original packet, we use that node as next hop for the destination from then on. This makes sure that only
-  when there’s a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
+  when there's a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
   NextHopRouter only 1 time). For the final retry, if no one actually relayed the packet, it will reset the next hop in order to
   fall back to the FloodingRouter again. Note that thus also intermediate hops will do a single retransmission if the intended
-  next-hop didn’t relay, in order to fix changes in the middle of the route.
+  next-hop didn't relay, in order to fix changes in the middle of the route.
 */
 class NextHopRouter : public FloodingRouter
 {
@@ -97,6 +98,9 @@ class NextHopRouter : public FloodingRouter
      */
     std::unordered_map<GlobalPacketId, PendingPacket, GlobalPacketIdHashFunction> pending;
 
+    // Add NextHopSelector for debug/analysis
+    NextHopSelector nextHopSelector;
+
     /**
      * Should this incoming filter be dropped?
      *
