diff --git a/src/mesh/NextHopRouter.cpp b/src/mesh/NextHopRouter.cpp
index f21974a2e..200c0c9e9 100644
--- a/src/mesh/NextHopRouter.cpp
+++ b/src/mesh/NextHopRouter.cpp
@@ -20,6 +20,22 @@ ErrorCode NextHopRouter::send(meshtastic_MeshPacket *p)
     p->next_hop = getNextHop(p->to, p->relay_node); // set the next hop
     LOG_DEBUG("Setting next hop for packet with dest %x to %x", p->to, p->next_hop);
 
+    // Debug: Compare with NextHopSelector
+    uint8_t selectorHop = nextHopSelector.getBestNextHop(p->to, p->relay_node);
+    if (selectorHop != p->next_hop) {
+        LOG_INFO("[NextHopDebug] NextHopRouter chose %x, NextHopSelector suggests %x for dest %x", p->next_hop, selectorHop, p->to);
+        // Print top candidates if available
+        auto candidates = nextHopSelector.getTopCandidates(p->to);
+        if (!candidates.empty()) {
+            LOG_INFO("[NextHopDebug] Top candidates for dest %x:", p->to);
+            int rank = 1;
+            for (const auto& cand : candidates) {
+                LOG_INFO("  #%d: nodeId=%x, successRate=%.2f, success=%u, fail=%u", rank, cand.nodeId, cand.successRate, cand.successCount, cand.failureCount);
+                if (++rank > 3) break;
+            }
+        }
+    }
+
     // If it's from us, ReliableRouter already handles retransmissions if want_ack is set. If a next hop is set and hop limit is
     // not 0 or want_ack is set, start retransmissions
     if ((!isFromUs(p) || !p->want_ack) && p->next_hop != NO_NEXT_HOP_PREFERENCE && (p->hop_limit > 0 || p->want_ack))
@@ -78,6 +94,9 @@ void NextHopRouter::sniffReceived(const meshtastic_MeshPacket *p, const meshtast
                     if (origTx->next_hop != p->relay_node) { // Not already set
                         LOG_INFO("Update next hop of 0x%x to 0x%x based on ACK/reply", p->from, p->relay_node);
                         origTx->next_hop = p->relay_node;
+                        
+                        // Record success in NextHopSelector
+                        nextHopSelector.recordSuccess(p->from, p->relay_node);
                     }
                 }
             }
@@ -216,6 +235,9 @@ int32_t NextHopRouter::doRetransmissions()
                     LOG_DEBUG("Reliable send failed, returning a nak for fr=0x%x,to=0x%x,id=0x%x", p.packet->from, p.packet->to,
                               p.packet->id);
                     sendAckNak(meshtastic_Routing_Error_MAX_RETRANSMIT, getFrom(p.packet), p.packet->id, p.packet->channel);
+                    
+                    // Record failure in NextHopSelector
+                    nextHopSelector.recordFailure(p.packet->to, p.packet->next_hop);
                 }
                 // Note: we don't stop retransmission here, instead the Nak packet gets processed in sniffReceived
                 stopRetransmission(it->first);
diff --git a/src/mesh/NextHopRouter.h b/src/mesh/NextHopRouter.h
index 6c2764aff..d7ed0d464 100644
--- a/src/mesh/NextHopRouter.h
+++ b/src/mesh/NextHopRouter.h
@@ -2,6 +2,7 @@
 
 #include "FloodingRouter.h"
 #include <unordered_map>
+#include "NextHopSelector.h"
 
 /**
  * An identifier for a globally unique message - a pair of the sending nodenum and the packet id assigned
@@ -53,10 +54,10 @@ class GlobalPacketIdHashFunction
   relayer of a packet, which bases this on information from a previous successful delivery to the destination via flooding.
   Namely, in the PacketHistory, we keep track of (up to 3) relayers of a packet. When the ACK is delivered back to us via a node
   that also relayed the original packet, we use that node as next hop for the destination from then on. This makes sure that only
-  when there’s a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
+  when there's a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
   NextHopRouter only 1 time). For the final retry, if no one actually relayed the packet, it will reset the next hop in order to
   fall back to the FloodingRouter again. Note that thus also intermediate hops will do a single retransmission if the intended
-  next-hop didn’t relay, in order to fix changes in the middle of the route.
+  next-hop didn't relay, in order to fix changes in the middle of the route.
 */
 class NextHopRouter : public FloodingRouter
 {
@@ -97,6 +98,9 @@ class NextHopRouter : public FloodingRouter
      */
     std::unordered_map<GlobalPacketId, PendingPacket, GlobalPacketIdHashFunction> pending;
 
+    // Add NextHopSelector for debug/analysis
+    NextHopSelector nextHopSelector;
+
     /**
      * Should this incoming filter be dropped?
      *
