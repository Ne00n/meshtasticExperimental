diff --git a/src/mesh/NextHopRouter.cpp b/src/mesh/NextHopRouter.cpp
index f21974a2e..5c594bd01 100644
--- a/src/mesh/NextHopRouter.cpp
+++ b/src/mesh/NextHopRouter.cpp
@@ -1,6 +1,6 @@
 #include "NextHopRouter.h"
 
-NextHopRouter::NextHopRouter() {}
+NextHopRouter::NextHopRouter() : nextHopOptimizer(nodeDB) {}
 
 PendingPacket::PendingPacket(meshtastic_MeshPacket *p, uint8_t numRetransmissions)
 {
@@ -78,6 +78,9 @@ void NextHopRouter::sniffReceived(const meshtastic_MeshPacket *p, const meshtast
                     if (origTx->next_hop != p->relay_node) { // Not already set
                         LOG_INFO("Update next hop of 0x%x to 0x%x based on ACK/reply", p->from, p->relay_node);
                         origTx->next_hop = p->relay_node;
+                        
+                        // Update route success statistics - no need to check isBroadcast since ACKs are always directed
+                        nextHopOptimizer.updateRouteSuccess(p->to, p->relay_node, p->hop_start - p->hop_limit);
                     }
                 }
             }
@@ -131,6 +134,9 @@ uint8_t NextHopRouter::getNextHop(NodeNum to, uint8_t relay_node)
     if (node && node->next_hop) {
         // We are careful not to return the relay node as the next hop
         if (node->next_hop != relay_node) {
+            // Get the best next hop based on route statistics
+            uint8_t bestNextHop = nextHopOptimizer.getBestNextHop(to, node->next_hop);
+            LOG_DEBUG("Next hop comparison for 0x%x: current=0x%x, optimized=0x%x", to, node->next_hop, bestNextHop);
             // LOG_DEBUG("Next hop for 0x%x is 0x%x", to, node->next_hop);
             return node->next_hop;
         } else
diff --git a/src/mesh/NextHopRouter.h b/src/mesh/NextHopRouter.h
index 6c2764aff..b69b2720e 100644
--- a/src/mesh/NextHopRouter.h
+++ b/src/mesh/NextHopRouter.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include "FloodingRouter.h"
+#include "NextHopOptimizer.h"
 #include <unordered_map>
 
 /**
@@ -53,10 +54,10 @@ class GlobalPacketIdHashFunction
   relayer of a packet, which bases this on information from a previous successful delivery to the destination via flooding.
   Namely, in the PacketHistory, we keep track of (up to 3) relayers of a packet. When the ACK is delivered back to us via a node
   that also relayed the original packet, we use that node as next hop for the destination from then on. This makes sure that only
-  when there’s a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
+  when there's a two-way connection, we assign a next hop. Both the ReliableRouter and NextHopRouter will do retransmissions (the
   NextHopRouter only 1 time). For the final retry, if no one actually relayed the packet, it will reset the next hop in order to
   fall back to the FloodingRouter again. Note that thus also intermediate hops will do a single retransmission if the intended
-  next-hop didn’t relay, in order to fix changes in the middle of the route.
+  next-hop didn't relay, in order to fix changes in the middle of the route.
 */
 class NextHopRouter : public FloodingRouter
 {
@@ -148,4 +149,7 @@ class NextHopRouter : public FloodingRouter
     /** Check if we should be relaying this packet if so, do so.
      *  @return true if we did relay */
     bool perhapsRelay(const meshtastic_MeshPacket *p);
+
+    // Next hop optimizer for route optimization
+    NextHopOptimizer nextHopOptimizer;
 };
\ No newline at end of file
