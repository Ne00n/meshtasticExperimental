diff --git a/src/mesh/RateLimiter.cpp b/src/mesh/RateLimiter.cpp
new file mode 100644
index 000000000..6b4a1a04d
--- /dev/null
+++ b/src/mesh/RateLimiter.cpp
@@ -0,0 +1,4 @@
+#include "RateLimiter.h"
+
+// Define the static member
+constexpr meshtastic_PortNum RateLimiter::RATE_LIMITED_PORTS[]; 
\ No newline at end of file
diff --git a/src/mesh/RateLimiter.h b/src/mesh/RateLimiter.h
new file mode 100644
index 000000000..7ae24db60
--- /dev/null
+++ b/src/mesh/RateLimiter.h
@@ -0,0 +1,88 @@
+#pragma once
+
+#include "configuration.h"
+#include "mesh-pb-constants.h"
+#include "MeshTypes.h"
+#include <unordered_map>
+#include <cstdint>
+
+class RateLimiter {
+private:
+    // Map of sender node number to last packet timestamp for each rate-limited port
+    std::unordered_map<NodeNum, std::unordered_map<meshtastic_PortNum, uint32_t>> lastPacketTimes;
+    
+    // Rate limit period in milliseconds (1 hour)
+    static constexpr uint32_t RATE_LIMIT_PERIOD_MS = 3600000;
+    
+    // List of port numbers that should be rate limited
+    static constexpr meshtastic_PortNum RATE_LIMITED_PORTS[] = {
+        meshtastic_PortNum_TELEMETRY_APP,
+        meshtastic_PortNum_NEIGHBORINFO_APP,
+        meshtastic_PortNum_NODEINFO_APP,
+        meshtastic_PortNum_POSITION_APP
+    };
+    
+    // Number of rate limited ports
+    static constexpr size_t NUM_RATE_LIMITED_PORTS = sizeof(RATE_LIMITED_PORTS) / sizeof(RATE_LIMITED_PORTS[0]);
+
+public:
+    /**
+     * Check if a packet should be rate limited
+     * @param from The sender's node number
+     * @param portnum The port number of the packet
+     * @return true if the packet should be rate limited (dropped), false otherwise
+     */
+    bool shouldRateLimit(NodeNum from, meshtastic_PortNum portnum) {
+        // Check if this port should be rate limited
+        bool isRateLimitedPort = false;
+        for (size_t i = 0; i < NUM_RATE_LIMITED_PORTS; i++) {
+            if (RATE_LIMITED_PORTS[i] == portnum) {
+                isRateLimitedPort = true;
+                LOG_DEBUG("Port %d is a rate-limited port", portnum);
+                break;
+            }
+        }
+        
+        if (!isRateLimitedPort) {
+            LOG_DEBUG("Port %d is not rate-limited, allowing packet", portnum);
+            return false; // Don't rate limit non-rate-limited ports
+        }
+        
+        uint32_t currentTime = millis();
+        auto& senderTimes = lastPacketTimes[from];
+        
+        // Check if we've seen a packet from this sender on this port recently
+        auto it = senderTimes.find(portnum);
+        if (it != senderTimes.end()) {
+            uint32_t timeSinceLastPacket = currentTime - it->second;
+            if (timeSinceLastPacket < RATE_LIMIT_PERIOD_MS) {
+                uint32_t remainingTime = RATE_LIMIT_PERIOD_MS - timeSinceLastPacket;
+                LOG_DEBUG("Rate limiting packet from node 0x%x on port %d. Last packet was %u ms ago, %u ms remaining in rate limit period", 
+                         from, portnum, timeSinceLastPacket, remainingTime);
+                return true; // Rate limit this packet
+            } else {
+                LOG_DEBUG("Rate limit period expired for node 0x%x on port %d. Last packet was %u ms ago", 
+                         from, portnum, timeSinceLastPacket);
+            }
+        } else {
+            LOG_DEBUG("First packet from node 0x%x on port %d, not rate limited", from, portnum);
+        }
+        
+        // Update the last packet time for this sender and port
+        senderTimes[portnum] = currentTime;
+        LOG_DEBUG("Updated last packet time for node 0x%x on port %d to %u", from, portnum, currentTime);
+        return false;
+    }
+    
+    /**
+     * Clear rate limit history for a specific node
+     * @param from The node number to clear history for
+     */
+    void clearNodeHistory(NodeNum from) {
+        if (lastPacketTimes.erase(from) > 0) {
+            LOG_DEBUG("Cleared rate limit history for node 0x%x", from);
+        } else {
+            LOG_DEBUG("No rate limit history found to clear for node 0x%x", from);
+        }
+    }
+}; 
\ No newline at end of file
diff --git a/src/mesh/Router.cpp b/src/mesh/Router.cpp
index fef29388e..41714e33a 100644
--- a/src/mesh/Router.cpp
+++ b/src/mesh/Router.cpp
@@ -622,6 +622,18 @@ void Router::handleReceived(meshtastic_MeshPacket *p, RxSource src)
         else
             printPacket("handleReceived(REMOTE)", p);
 
+        // Check rate limiting after successful decode
+        if (p->which_payload_variant == meshtastic_MeshPacket_decoded_tag) {
+            LOG_DEBUG("Checking rate limit for decoded packet from node 0x%x on port %d", p->from, p->decoded.portnum);
+            if (rateLimiter.shouldRateLimit(p->from, p->decoded.portnum)) {
+                LOG_DEBUG("Rate limiting decoded packet from node 0x%x on port %d - dropping packet", p->from, p->decoded.portnum);
+                cancelSending(p->from, p->id);
+                skipHandle = true;
+            } else {
+                LOG_DEBUG("Decoded packet from node 0x%x on port %d passed rate limit check", p->from, p->decoded.portnum);
+            }
+        }
+
         // Neighbor info module is disabled, ignore expensive neighbor info packets
         if (p->which_payload_variant == meshtastic_MeshPacket_decoded_tag &&
             p->decoded.portnum == meshtastic_PortNum_NEIGHBORINFO_APP &&
diff --git a/src/mesh/Router.h b/src/mesh/Router.h
index 58ca50f3d..86182a158 100644
--- a/src/mesh/Router.h
+++ b/src/mesh/Router.h
@@ -7,6 +7,7 @@
 #include "PacketHistory.h"
 #include "PointerQueue.h"
 #include "RadioInterface.h"
+#include "RateLimiter.h"
 #include "concurrency/OSThread.h"
 
 /**
@@ -18,6 +19,9 @@ class Router : protected concurrency::OSThread, protected PacketHistory
     /// Packets which have just arrived from the radio, ready to be processed by this service and possibly
     /// forwarded to the phone.
     PointerQueue<meshtastic_MeshPacket> fromRadioQueue;
+    
+    /// Rate limiter for controlling packet frequency
+    RateLimiter rateLimiter;
 
   protected:
     RadioInterface *iface = NULL;
